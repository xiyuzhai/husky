//! As we expect Lean in our projects to be autogenerated by visored, we group defns into arena for convenience
pub mod def;
pub mod variable;

use self::{def::*, variable::*};
use crate::*;
use expr::LnMirExprIdx;
use idx_arena::{Arena, ArenaIdx, ArenaIdxRange, ArenaRef};
use lean_coword::ident::LnIdent;
use lean_item_path::namespace::LnNamespace;

pub enum LnItemDefnData {
    Variable {
        symbol: LnIdent,
        ty: LnMirExprIdx,
    },
    Def {
        symbol: LnIdent,
        ty: LnMirExprIdx,
        body: LnMirDefBody,
    },
    Group {
        defns: LnItemDefnIdxRange,
        meta: LnMirItemDefnGroupMeta,
    },
}

pub enum LnItemDefnChild {
    Expr(LnMirExprIdx),
    Defn(LnItemDefnIdx),
    DefBody(LnMirDefBody),
}

impl LnItemDefnData {
    pub(crate) fn children(&self) -> Vec<LnItemDefnChild> {
        match *self {
            LnItemDefnData::Variable { .. } => vec![],
            LnItemDefnData::Group { defns, .. } => {
                defns.into_iter().map(LnItemDefnChild::Defn).collect()
            }
            LnItemDefnData::Def { symbol, ty, body } => {
                vec![LnItemDefnChild::Expr(ty), LnItemDefnChild::DefBody(body)]
            }
        }
    }
}

pub enum LnMirItemDefnGroupMeta {
    Paragraph,
    Sentence,
    Division(Option<LnNamespace>),
    Environment(LnNamespace),
}

pub type LnItemDefnArena = Arena<LnItemDefnData>;
pub type LnItemDefnArenaRef<'a> = ArenaRef<'a, LnItemDefnData>;
pub type LnItemDefnIdx = ArenaIdx<LnItemDefnData>;
pub type LnItemDefnIdxRange = ArenaIdxRange<LnItemDefnData>;

impl std::fmt::Display for LnMirItemDefnGroupMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LnMirItemDefnGroupMeta::Paragraph => write!(f, "paragraph"),
            LnMirItemDefnGroupMeta::Sentence => write!(f, "sentence"),
            LnMirItemDefnGroupMeta::Division(_) => write!(f, "division"),
            LnMirItemDefnGroupMeta::Environment(_) => write!(f, "environment"),
        }
    }
}
